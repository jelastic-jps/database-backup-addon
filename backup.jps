type: update
jpsVersion: 6.1.1
name: Database Backup/Restore for the filesystem and the databases
id: db-backup
targetEditions: any
logo: /images/backup-logo.png
description: Backup Add-On for the database. It can be used to create scheduled backups according to any required timezone and restore corrupted databases, even if the content has been completely deleted.
baseUrl: https://raw.githubusercontent.com/sych74/database-backup-addon/pitr

targetNodes:
  nodeType: 
    - redis
    - redis7
    - redis6
    - postgresql
    - postgres15
    - postgres14
    - postgres13
    - postgres12
    - postgres11
    - mysql
    - mysql5
    - mysql8
    - mariadb-dockerized
    - mariadb10
    - mariadb11
    - mongodb-dockerized
    - mongodb
    - mongo
    - perconadb
    - percona8
    - percona5

settings:
  main:
    fields:
      - type: radio-fieldset
        name: scheduleType
        hidden: false
        default: '1'
        values:
          - value: 1 
            caption: Pre-defined
          - value: 2 
            caption: Custom
          - value: 3 
            caption: Manual (crontab)
            tooltip: "<span>A simple <a href=\"https://en.wikipedia.org/wiki/Cron#Overview\" target=\"_blank\"> cron-based</a>
    scheduler to automatically start the backup process based on prescribed timing
    instructions.</span><div><b>Note</b> that the required timestamps should be specified
    respectively to the UTC time zone.</div>" 
        showIf:
          1:
            - name: cronTime
              caption: Backup schedule
              type: list
              editable: false
              values:
                - value: 0 * * * * 
                  caption: "Hourly (at minute 0)"
                - value: 0 0 * * * 
                  caption: "Daily (at 00:00)"
                - value: 0 0 * * 0 
                  caption: "Weekly (at 00:00 on Sunday)"
                - value: 0 0 1 * *
                  caption: "Monthly (at 00:00 on day 1)"
              default: 0 0 * * *
          2:
            - type: string
              name: backupTime
              caption: Time
              inputType: time
              default: "09:00"
              cls: x-form-text
              width: 120
              required: true
            - caption: Days
              type: compositefield
              name: days
              defaultMargins: 0 12 0 0
              items:
                - name: sun
                  value: true
                  type: checkbox
                  caption: Su
                - name: mon
                  value: true
                  type: checkbox
                  caption: Mo
                - name: tue
                  value: true
                  type: checkbox
                  caption: Tu
                - name: wed
                  value: true
                  type: checkbox
                  caption: We
                - name: thu
                  value: true
                  type: checkbox
                  caption: Th
                - name: fri
                  value: true
                  type: checkbox
                  caption: Fr
                - name: sat
                  value: true
                  type: checkbox
                  caption: Sa
            - name: "tz"
              caption: "Time Zone"
              type: "list"
              required: true
              editable: true
              forceSelection: true
              values: values
          3:
            - name: cronTime
              caption: Crontab             
              type: string
              default: 0 0 * * *
              regexText: Cron syntax is incorrect!
              regex: "^(((([\\\\*]{1}){1,})|((\\\\*\\\\\\/){0,1}(([0-9\\/\\*\\-\\,]{1}){1,}|(([1-5]{1}){1}([0-9\\/\\*\\-\\,]{1}){1,}){1})))
              ((([\\\\*]{1}){1,})|((\\\\*\\\\\\/){0,1}(([0-9\\/\\*\\-\\,]{1}){1,}|(([1]{1}){1}([0-9\\/\\*\\-\\,-]{1}){1,}){1}|([2]{1}){1}([0-3]{1}){1})))
              ((([\\\\*]{1}){1})|((\\\\*\\\\\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9\\/\\*\\-\\,]{1}){1,5}){1}|([3]{1}){1}([0-1]{1}){1})))
              ((([\\\\*]{1}){1})|((\\\\*\\\\\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9\\/\\*\\-\\,]{1}){1,}){1}|([3]{1}){1}([0-1]{1}){1}))|(jan|JAN|feb|FEB|mar|MAR|apr|APR|may|MAY|jun|JUN|jul|JUL|aug|AUG|sep|SEP|okt|OKT|nov|NOV|dec|DEC)(-?\\w+?)?)
              ((([\\\\*]{1}){1})|((\\\\*\\\\\\/){0,1}(([0-7]{1,}(-?[0-7]?(,[0-7]){0,6})){1}))|((sun|SUN|mon|MON|tue|TUE|wed|WED|thu|THU|fri|FRI|sat|SAT)?(,(sun|SUN|mon|MON|tue|TUE|wed|WED|thu|THU|fri|FRI|sat|SAT)){0,6})(-?\\w+?)?))$|^(@(reboot|yearly|annualy|monthly|weekly|daily|hourly))$"
      - caption: Backup storage
        type: list
        tooltip: "The environment with backup storage to be used for backups creation. Presence of this environment is obligatory."  
        name: storageName
        dependsOn: region
        required: true
      - type: spinner
        name: backupCount
        caption: Number of backups
        tooltip: "The number of newest backups to be kept during rotation."  
        min: 1
        max: 30
        default: 5
      - type: toggle
        name: isAlwaysUmount
        caption: Always umount
        tooltip: "Always unmount backup storage when backup/restore is finished." 
        value: false
        hidden: false
      - type: toggle
        name: isPitr
        caption: PITR
        tooltip: "Point in time recovery" 
        value: false
        hidden: false
        showIf:
          true:
          - type: displayfield
            cls: warning
            height: 30,
            hideLabel: true,
            markup: "Database does not configured for PITR support. Please push apply for automatic configuring or close and manually configure acording to instruction and reinstall addon"          
      - type: displayfield
        name: displayPitr
        markup: ""
        hidden: true
        hideLabel: true
        cls: warning
      - type: displayfield
        name: displayfield
        markup: Please specify the database user that has enough privileges to access and modify all the databases stored on server. Username and password are required for all the DB servers except Redis.
        hidden: false
        hideLabel: true
        cls: warning
      - hideLabel: false
        hidden: false
        type: string
        caption: Database User
        name: dbuser
        default: root
        tooltip: In case you restore non-native database backup do not forget to provide its credentials instead of initial ones with help of add-on Configure action. It is relevant to <b>sqldb</b> databases and <b>MongoDB</b> only.
      - hideLabel: false
        hidden: false
        type: string
        inputType: password
        caption: Database Password
        default: IBOkks15239
        name: dbpass
    onBeforeInit: scripts/configOnBeforeInit.js
        
  restore:
    fields: []
    onBeforeInit: |
      import org.json.JSONObject;
      var storage_unavailable_markup = "";
      var storageInfo = getStorageNodeid();
      var storageEnvDomain = storageInfo.storageEnvShortName;
      var storageEnvMasterId = storageInfo.storageNodeId;
      var checkSchemaCommand = "if grep -q '^SCHEME=' /.jelenv; then echo true; else echo false; fi";
      var mysql_cluster_markup = "Be careful when restoring the dump from another DB environment (or environment with another replication schema) to the replicated MySQL/MariaDB/Percona solution.";
      var recovery_addon_markup = "Please use Database Corruption Diagnostic add-on for check after restore, and Database Recovery Add-on for fix if it is needed.";

      resp = jelastic.env.control.GetEnvInfo(storageEnvDomain, session);
      if (resp.result != 0 && resp.result != 11) return resp;
      if (resp.result == 11) {
          storage_unavailable_markup = "Storage environment " + "${settings.storageName}" + " is deleted.";
      } else if (resp.env.status == 1) {
          var baseUrl = jps.baseUrl;
          var updateResticOnStorageCommand = "wget --tries=10 -O /tmp/installUpdateRestic " + baseUrl + "/scripts/installUpdateRestic && mv -f /tmp/installUpdateRestic /usr/sbin/installUpdateRestic && chmod +x /usr/sbin/installUpdateRestic && /usr/sbin/installUpdateRestic";
          var respUpdate = api.env.control.ExecCmdById(storageEnvDomain, session, storageEnvMasterId, toJSON([{"command": updateResticOnStorageCommand, "params": ""}]), false, "root");
          if (respUpdate.result != 0) return respUpdate;
          var backups = jelastic.env.control.ExecCmdById(storageEnvDomain, session, storageEnvMasterId, toJSON([{"command": "/root/getBackupsAllEnvs.sh", "params": ""}]), false, "root").responses[0].out;
          var backupList = toNative(new JSONObject(String(backups)));
          var envs = prepareEnvs(backupList.envs);
          var backups = prepareBackups(backupList.backups);
      } else {
          storage_unavailable_markup = "Storage environment " + storageEnvDomain + " is unavailable (stopped/sleeping).";
      }

      var checkSchema = api.env.control.ExecCmdById("${env.name}", session, ${targetNodes.master.id}, toJSON([{"command": checkSchemaCommand, "params": ""}]), false, "root");
      if (checkSchema.result != 0) return checkSchema;

      function getStorageNodeid(){
          var storageEnv = '${settings.storageName}'
          var storageEnvShortName = storageEnv.split(".")[0]
          var resp = jelastic.environment.control.GetEnvInfo(storageEnvShortName, session)
          if (resp.result != 0) return resp
          for (var i = 0; resp.nodes; i++) {
              var node = resp.nodes[i]
              if (node.nodeGroup == 'storage' && node.ismaster) {
                  return { result: 0, storageNodeId: node.id, storageEnvShortName: storageEnvShortName };
              }
          }
      }

      function prepareEnvs(values) {
          var aResultValues = [];

          values = values || [];

          for (var i = 0, n = values.length; i < n; i++) {
              aResultValues.push({ caption: values[i], value: values[i] });
          }

          return aResultValues;
      }

      function prepareBackups(backups) {
          var oResultBackups = {};
          var aValues;

          for (var envName in backups) {
              if (Object.prototype.hasOwnProperty.call(backups, envName)) {
                  aValues = [];

                  for (var i = 0, n = backups[envName].length; i < n; i++) {
                      aValues.push({ caption: backups[envName][i], value: backups[envName][i] });
                  }

                  oResultBackups[envName] = aValues;
              }
          }

          return oResultBackups;
      }

      if (storage_unavailable_markup === "") {
          if ('${settings.isPitr}' == 'true') {
              settings.fields.push({
                  "type": "toggle",
                  "name": "isPitr",
                  "caption": "PITR",
                  "tooltip": "Point in time recovery",
                  "value": true,
                  "hidden": false,
                  "showIf": {
                    "true": [
                     {
                          "caption": "Restore from",
                          "type": "list",
                          "name": "backupedEnvName",
                          "required": true,
                          "values": envs
                      }, {
                          "caption": "Time for restore",
                          "type": "string",
                          "name": "restoreTime",
                          "inputType": "datetime-local",
                          "cls": "x-form-text",
                          "required": true
                      }
                    ],
                    "false": [
                     {
                          "caption": "Restore from",
                          "type": "list",
                          "name": "backupedEnvName",
                          "required": true,
                          "values": envs
                      }, {
                          "caption": "Backup",
                          "type": "list",
                          "name": "backupDir",
                          "required": true,
                          "tooltip": "Select the time stamp for which you want to restore the DB dump",
                          "dependsOn": {
                              "backupedEnvName" : backups
                          }
                      }
                    ]
                  }
              });
              if (checkSchema.responses[0].out == "true") {
                  settings.fields.push(
                      {"type": "displayfield", "cls": "warning", "height": 30, "hideLabel": true, "markup": mysql_cluster_markup}
                  );
                  settings.fields.push(
                      {"type": "displayfield", "cls": "warning", "height": 30, "hideLabel": true, "markup": recovery_addon_markup}
                  );
              }
          } else {
              settings.fields.push({
                  "caption": "Restore from",
                  "type": "list",
                  "name": "backupedEnvName",
                  "required": true,
                  "values": envs
              }, {
                  "caption": "Backup",
                  "type": "list",
                  "name": "backupDir",
                  "required": true,
                  "tooltip": "Select the time stamp for which you want to restore the DB dump",
                  "dependsOn": {
                      "backupedEnvName" : backups
                  }
              });
              if (checkSchema.responses[0].out == "true") {
                  settings.fields.push(
                      {"type": "displayfield", "cls": "warning", "height": 30, "hideLabel": true, "markup": mysql_cluster_markup}
                  );
                  settings.fields.push(
                      {"type": "displayfield", "cls": "warning", "height": 30, "hideLabel": true, "markup": recovery_addon_markup}
                  );
              }
          }
      } else {
          settings.fields.push(
              {"type": "displayfield", "cls": "warning", "height": 30, "hideLabel": true, "markup": storage_unavailable_markup}
          )
      }

      return settings;
    
  pitr:
    fields: []
    onBeforeInit: |
      var respOut;
      var pitr_conf_error_markup = "Database doesnt configured for PITR support. Please push apply for automatic configuring or close and manually configure acording to instruction and reinstall addon";
      var pitr_conf_success_markup = "Database configured for PITR support";
      var recovery_addon_markup = "Please use Database Corruption Diagnostic add-on for check after restore, and Database Recovery Add-on for fix if it is needed.";

      var checkPitrCmd = "wget " + '${baseUrl}' + "/scripts/pitr.sh -O /root/pitr.sh &>> /var/log/run.log; bash /root/pitr.sh checkPitr " + '${settings.dbuser}' + " " + '${settings.dbpass}';
      resp = jelastic.env.control.ExecCmdById('${env.envName}', session, '${nodes.sqldb.master.id}', toJSON([{ command: checkPitrCmd }]), true, "root");
      if (resp.result != 0) return resp;
      respOut = resp.responses[0].out;
      respOut = JSON.parse(respOut);
      if (respOut.result == 702) {
        settings.fields.push({
          caption: "PITR",
          type: "toggle",
          name: "isPitr",
          tooltip: "Point in time recovery",
          values: false,
          hidden:  false,
          disabled: true
        }, {
          type: "displayfield",
          cls: "warning",
          height: 30,
          hideLabel: true,
          markup: pitr_conf_error_markup
        });        
      } else {
        settings.fields.push({
          caption: "PITR",
          type: "toggle",
          name: "isPitr",
          tooltip: "Point in time recovery",
          values: false,
          hidden:  false,
          disabled: false
        }, {
          type: "displayfield",
          cls: "success",
          height: 30,
          hideLabel: true,
          markup: pitr_conf_success_markup
        });
      }
      return settings;
      
onBeforeInit: scripts/backupOnBeforeInit.js

buttons:
- caption: Backup Now
  action: backup
  loadingText: Backing up...
  confirmText: Do you want to initiate the backup process?
  successText: The backup process has been finished successfully.

- caption: Configure
  action: configure
  settings: main
  loadingText: Configuring...
  successText: The backup configs have been updated successfully.
  
- caption: Restore
  action: restore
  loadingText: Restoring...
  settings: restore
  successText: The backup have been successfully restored.
  title: Restore Backup
  submitButtonText: Restore
  confirmText: You are going to restore from a backup, which will override all your existing data. This action cannot be canceled or reverted. Do you want to proceed?

globals:
  scriptSufix: db-backup

onInstall:

  - checkAddons
  - installRestic
  - setSchedule

onUninstall:
  - callScript: uninstall
  - removeScript

onBeforeDelete:
  - callScript: uninstall
  - removeScript
  
onAfterRedeployContainer[${targetNodes.nodeGroup}]:
  - installRestic
  
onAfterClone:     
  - script: return {result:0, jps:MANIFEST};
  - install: ${response.jps}
    nodeGroup: ${targetNodes.nodeGroup}
    envName: ${event.response.env.envName}
    settings:
      scheduleType: ${settings.scheduleType}
      storageName: ${settings.storageName}
      cronTime: ${settings.cronTime}
      backupTime: ${settings.backupTime}
      sun: ${settings.sun} 
      mon: ${settings.mon}
      tue: ${settings.tue}
      wed: ${settings.wed}
      thu: ${settings.thu}
      fri: ${settings.fri}
      sat: ${settings.sat}
      tz: ${settings.tz}    
      backupCount: ${settings.backupCount}
      isAlwaysUmount: ${settings.isAlwaysUmount}

onAfterConfirmTransfer: setSchedule

actions:
  checkAddons:
    - script: |-
        var onAfterReturn = { setGlobals: {} },
          glbs = onAfterReturn.setGlobals,
          resp = api.marketplace.app.GetAddonList({
            search: {},
            envName: "${env.name}",
            session: session
          });
        if (resp.result != 0) return resp;
        glbs["alreadyInstalled"] = false;
        for (let i = 0, n = resp.apps.length; i < n; i++) {
        if (resp.apps[i].isInstalled) {
            if (resp.apps[i].app_id == 'wp-backup') {
              glbs["alreadyInstalled"] = true;
              break;
            } 
          }
        }
        return { result: 0, onAfterReturn: onAfterReturn };
    - if ('${globals.alreadyInstalled}' == 'true' ):
      - stopEvent:
          type: warning
          message: Database backup add-on is already installed on ${env.name}. Database backup addon installation is not possible.

  installRestic:
    cmd [${targetNodes.nodeGroup}]: |-
        wget --tries=10 -O /tmp/installUpdateRestic ${baseUrl}/scripts/installUpdateRestic && \
        mv -f /tmp/installUpdateRestic /usr/sbin/installUpdateRestic && \
        chmod +x /usr/sbin/installUpdateRestic && /usr/sbin/installUpdateRestic
    user: root

  installScript:
    - removeScript
    - getStorageCtid
    - script: ${baseUrl}/scripts/create-backup-main-script.js?_r=${fn.random}
      params:
        scriptName: ${env.envName}-${globals.scriptSufix}
        baseUrl: ${baseUrl}
        cronTime: ${this.cronTime}
        backupCount: ${this.backupCount}
        userId: ${env.uid}
        storageNodeId: ${response.storageCtid}
        backupExecNode: ${targetNodes.master.id}
        storageEnv: ${response.storageEnvShortName}
        isAlwaysUmount: ${this.isAlwaysUmount}
        isPitr: ${this.isPitr}
        nodeGroup: ${this.nodeGroup}
        dbuser: ${this.dbuser}
        dbpass: ${this.dbpass}

  callScript:
    script: |-
      var resp = jelastic.dev.scripting.Eval(appid, session, '${env.envName}-${globals.scriptSufix}', {action:"${this}"});
      if (resp.result === 1702 && "${this}" == "uninstall") {
          return { result: 0, out: "script not found" };
      } else {
          return resp.response || resp;
      }
      
  removeScript:
    script: |-
      var resp = jelastic.dev.scripting.GetScript(appid, session, '${env.envName}-${globals.scriptSufix}');
      if (resp.result === 0) {
          var resp = jelastic.dev.scripting.DeleteScript(appid, session, '${env.envName}-${globals.scriptSufix}');
          return resp.response || resp;
      }
      return { result: 0 };

  backup:
    - callScript: backup
    - deleteDBdump
    
  restore:
    - cmd[${targetNodes.nodeGroup}]: echo "${settings.backupedEnvName}" > /root/.backupedenv
      user: root
    - if ("${settings.isPitr}" == "true"):
      - script: |
          var dateTimeInput = '${settings.restoreTime}';
          var [date, time] = dateTimeInput.split('T');
          var formattedDateTime = date + " " + time.slice(0, 5) + ":00";
          return api.environment.file.Write({ 
            envName: '${env.envName}',
            session: session,
            path: "/root/.backuptime",
            nodeGroup: "${targetNodes.nodeGroupp}",
            nodeid: "-1",
            userName: "root",
            body: formattedDateTime
          });
    - else:
      - cmd[${targetNodes.nodeGroup}]: echo "${settings.backupDir}" > /root/.backupid;
        user: root        
    - callScript: restore
    - deleteDBdump
    
  deleteDBdump:
    - cmd[${targetNodes.nodeGroup}]: |-
        [ -f /root/db_backup.sql ] && rm -f /root/db_backup.sql || exit 0;
      user: root    

  configure:
    - setSchedule
        
  getStorageCtid:
    - script: scripts/getStorageCtid.js
        
  convert:
    - script: |
        var resp = {result:0, onAfterReturn: {setGlobals:{cron: ""}}}, offset = java.util.TimeZone.getTimeZone("${settings.tz}").getRawOffset(),
            setGlobals = resp.onAfterReturn.setGlobals;
        
        var time = "${settings.backupTime}".split(":"),
            d1 = new Date(2020, 1, 10, parseInt(time[0],10), parseInt(time[1],10)),
            d2 = new Date(d1.getTime() - offset),
            dd = d2.getDate() - d1.getDate(),
            days = getDays([${settings.sun:0}, ${settings.mon:0}, ${settings.tue:0}, ${settings.wed:0}, ${settings.thu:0}, ${settings.fri:0}, ${settings.sat:0}], dd);

        setGlobals.cron = d2.getMinutes() + " " + d2.getHours() + " * * " + days.join(",");


        function getDays(settings, dd) {
          var days = [];
          for (var i = 0, n = settings.length; i < n; i++) {
            if (settings[i]) {
              var day = i + dd;
              if (day < 0) day +=7; else if (day > 6) day -=7;
              days.push(day);
            }
          }
          days.sort();
          return days;
        }
        return resp;

  setSchedule:
    - setGlobals: 
        storageEnv: ${settings.storageName}
        isAlwaysUmount: ${settings.isAlwaysUmount}
        isPitr: ${settings.isPitr}
    - if ("${settings.scheduleType}" == 2):
      - convert
    - else:
      - setGlobals:
          cron: ${settings.cronTime}
    - if ("${settings.isAlwaysUmount}" == "true"):
      - removePermanentMount
    - else:
      - removePermanentMount
      - addPermanentMount
    - if ("${settings.isPitr}" == "true"): setupPitr      
    - installScript:
        cronTime: ${globals.cron}
        backupCount: ${settings.backupCount}
        isAlwaysUmount: ${globals.isAlwaysUmount}
        isPitr: ${globals.isPitr}
        nodeGroup: ${targetNodes.nodeGroup}
        dbuser: ${settings.dbuser}
        dbpass: ${settings.dbpass}

  setupPitr:
    cmd[${nodes.sqldb.master.id}]: |-
        wget --tries=10 -O /tmp/pitr.sh ${baseUrl}/scripts/pitr.sh && \
        chmod +x /tmp/pitr.sh && /tmp/pitr.sh setupPitr ${settings.dbuser} ${settings.dbpass};

  addPermanentMount:
    - getStorageCtid
    - script: |
        return jelastic.env.file.AddMountPointById("${env.envName}", session, "${targetNodes.master.id}", "/opt/backup", "nfs4", null, "/data/", "${response.storageCtid}", "DBBackupRestore", false);

  removePermanentMount:
    - getStorageCtid
    - script: |
        var allMounts = jelastic.env.file.GetMountPoints("${env.envName}", session, "${targetNodes.master.id}").array;
        for (var i = 0, n = allMounts.length; i < n; i++) {
            if (allMounts[i].path == "/opt/backup" && allMounts[i].type == "INTERNAL") {
              resp = jelastic.env.file.RemoveMountPointById("${env.envName}", session, "${targetNodes.master.id}", "/opt/backup");
              if (resp.result != 0) { return resp; }
            }
        }
        allMounts = jelastic.env.file.GetMountPoints("${env.envName}", session).array;
        for (var i = 0, n = allMounts.length; i < n; i++) {
            if (allMounts[i].path == "/opt/backup" && allMounts[i].type == "INTERNAL") {
              resp = jelastic.env.file.RemoveMountPointByGroup("${env.envName}", session, "sqldb", "/opt/backup");
              if (resp.result != 0) { return resp; }
            }
        }
        return { "result": 0 };
